# info-sec assignment

* md 사용법: <https://gist.githinsb.com/ihoneymon/652be052a0727ad59601>

###### 7월 3일 교육 내용

## 1. 기초보안 프로그래밍
by 전상현(보안제품개발 멘토)  
1) <ins>악성 코드? 악성 파일?</ins>
* 악성 코드는 악의적인 행위를 수행하는 코드의 집합.
* 악성 파일은 악성 코드를 내포하고 있는 파일(실행 파일형/문서 파일형/매크로형 등)

2) <ins>취약점과 공격 벡터</ins>
* 취약점은 특정 목적으로 개발된 애플리케이션이 의도치 않은 방식으로 동작하도록 유도하는 지점.
* 공격 벡터는 취약점이 유발되도록 외부에서 변형할 수 있는 요인을 말함.
* 문서형 악성 파일의 공격 원리
    * 가. 실행 -> 취약점 발현 -> 스택 오염 - > RET 변조 -> EIP 이동-> 악성코드 실행
* 고도화된 문서형 악성파일은 취약점을 이용해서 악성 코드를 실행하도록 유도 -> 매크로를 이용한 문서형 악성파일은 자동 실행 스크립트로 악성 행위를 수행

3) <ins>백신의 동작 과정</ins>
* (사용자 PC) 사용자 PC에 실시간으로 감시하는 엔진 존재(외부 파일을 탐지하여 삭제할지, 업로드할지, 그대로 둘지 결정) -> 시그니처(hash)를 악성파일 시그니처(hash)와 비교.
* (파일을 업로드할 경우, 보안회사 서버)신규 샘플을 수집하고, 악성코드 분석엔진을 통해 샘플을 분석. 이 후 분석 결과를 악성파일 시그니처(hash)에 업데이트함.
_cf) C&C 서버 찾는 방법: 갑자기 여러 감염된 봇이 하나의 컴퓨터와 통신을 하게 되면 의심 대상_  

4) <ins>분석 기술의 다양성</ins>
* 동적 분석 vs 정적 분석 vs 하이브리드 분석
    * 가. 동적 분석: 실행해서 분석.
    * 나. 정적 분석: 실행하지 않고 분석.
    * 다. 하이브리드 분석의 예시: 난독화 -> 동적 실행으로 분석 + 그 이후 메모리를 정적 분석
* 동적 분석의 세부 분류
    * 가. 어셈블리 레벨
    * 나. 익스플로잇
    * 다. 메모리 분석(알고리즘 등으로 찾는 게 아니라 메모리 전체를 주기적으로 스캔해서 쉘 코드를 찾아냄)
    * 라. API(행위) 분석
* 정적 분석의 세부 분류
    * 가. 애뮬레이션(동적과 조금 비교하기 힘들 수 있지만 정적 분석으로 분류됨)
    * 나. 리소스 분석
    * 다. 구문 분석
    * 라. 파일 포맷 분석
    * 마. 시그니쳐
    * 바. 인공지능(패턴 보는 것은 전부 인공지능이라고 보면 된다)

5) <ins>정적 분석 엔진</ins>
* 윈도우의 “알려진 파일 형식의 파일 확장명 숨기기” 기능을 통해 숨겨진 악성 문서 파일인 “이력서.pdf.exe” 라는 파일을 어떻게 진단할 것인가?
    * 가. 파일명 찾기
    * 나 파일 타입 비교
    * 다. 아이콘 확인
    * 라. 행위 파악
* 페이콘(fake + icon): 아이콘으로 장난치는 행위. 이에 대한 진단 방법.
    * 가. PE 파일에서 icon 추출 -> 리소스 데이터 파싱, 많은 아이콘 중 대표 아이콘 분리
    * 나. 형태 인식 알고리즘 개발 -> 색상 변종, 이동 변종, 솔드엔페퍼(salt & pepper) 변종, 크기 변종 탐지
    * 다. PE 파일 포맷.
* PE 파일 포맷.
    * 가. ‘MZ’가 맨 첫 바이트
    * 나. PEView 라는 툴을 활용하여 분석
* 매크로 파일: 문서 파일에 존재하는 자동화된 스크립트. PE 파일과 동일한 수준의 위험도를 갖는 스크립트. 문서를 열면 자동으로 실행됨. 자동 실행 함수 이름: AutoOpen, Document Open, Document Close 등.

6) <ins>동적 분석 엔진</ins>
* 행위기반 분석 엔진. 행위란 시스템 API를 의미하고 행위 단위로 이벤트를 받는 분석 엔진이다.
    * 가 행위기반 엔진의 4단계: 행위 추출 -> 행위 탐지(악성 행위 사슬) -> 행위 차단(미러링-빠름, 흐름 제어-느림) -> 행위 해석(악성 행위에 대한 기술, 분석 리포트)
* 행위 추출 기술.
    * 가. 시스템 드라이버(시스템에서 발생하는 모든 행위를 볼 수 있음. 가장 좋은 기술)
    * 나. 후킹
    * 다. 디버거(일반적인 exe 파일도 디버거를 통해 하나하나 행동을 분석 가능)
* 어셈블리 기반 분석 엔진. 함수 안에서 일어나는 모든 일들을 분석할 수 있음. 대신 중간 지점을 잡아야 되는데, 그러한 지점을 브레이크 포인트라고 함.
    * 가. 메모리 동적으로 할당할 때 초기화되지 않은 메모리에는 쓰레기 값이 들어가 있음. 하지만 디버그debug 모드(<->릴리즈release 모드)로 동작하면 0xCC로 채워져 있음.
    * 나. 다양한 프로세스 이벤트를 받을 수 있으며 다양한 Exception이 존재.
* 브레이크 포인트 동작의 이해
    * 가. CC를 코드의 시작 영역에 잘 심어주지 않으면 무시되고 상수취급 될 수 있음.
    * 나. 그렇다면 브레이크 코드를 잡음으로써 메모리 흐름에서 CC가 덮어쓰게 되는 코드의 행방은??
        * A. 변조 되기 전의 원본 코드로 복구(어딘가에 보관)
        * B. 그 지점(CC가 있는)을 읽게 되면 EIP를 1바이트 뒤로 이동
        * C. Single step으로 명령 하나만 실행
        * D. 다시 해당 지점을 0xCC로 변경
        * E. Continue로 재개 

7) <ins>간단한 퀴즈</ins>
![GetSystemTime](https://user-images.githubusercontent.com/63287638/124373196-29a3bb00-dccb-11eb-8033-f850206e1537.png)  
* 에서 예외처리가 필요한 곳은?  
    * 가. 안에 있는 GetSystemTime는 return 값이 void 이므로 에러가 안 남.
    * 나. Null pointer exception. pOutTime에 대한 null check를 안 함(사실 모든 함수의 마지막 함수로 불리기 때문에 널 체크가 불필요. 비효율적).
    * 다. memcpy의 오버플로우? 오버플로우 날 일이 없음.
    * 라. 따라서 완벽한 함수임.

![Sleep(0)](https://user-images.githubusercontent.com/63287638/124373206-3b855e00-dccb-11eb-968b-be917903f230.png)  
* 다음 패킷처리 프로그램에서 Sleep(0)의 의미는?  
    * 가. CPU 스케쥴링 양도를 위해.
    * 나. 0 다음으로 큰 정수인 1을 넣으면 처리가 늦어짐(1초에 1000번밖에 실행을 못 함).



## 2. 보안제품개발 인트로
by 박수현(보안제품개발 멘토)  
1) <ins>보안제품들 한눈에</ins>  
![in one shot](https://user-images.githubusercontent.com/63287638/124376197-bf961080-dce0-11eb-9ca9-d9d106d6894a.png)  


## 3. 기초암호학
1) <ins>암호학 소개</ins>
* 암호학(Cryptology): 그리스어 크립토스(비밀)과 로고스(학문)의 합성어로 여러 가지 형태의 암호화 및 복호화 방법을 만드는 암호와 그것을 해석하고 분석하는 암호 해독을 포함.
* 암/복호화 과정. 송신자의 P.T -> 암호화(Enc with K) -> C.T가 네트워크를 지나쳐 송신, 이 네트워크에서 도청이 가능 -> C.T를 받은 수신자는 복호화(Dec with K) -> 해서 P.T를 얻음
_key가 없으면 암/복호화가 아님. ex. Base64 인코딩_  
* 암호의 목적
    * 가. 기밀성(Confidentiality): 인가된 사람, 기관에게만 공개되고 허가된 시간이나 허가된 방법에 의해서만 처리되는 자료 및 정보의 특성. 비밀성이라고도 함. 대칭키/공개키 암호를 사용함으로써 보장
    * 나. 무결성(Integrity): 비인가된 자에 의한 정보의 변경, 삭제, 생성 등으로부터 정보를 보호하여 정보의 정확성, 완전성이 보장되어야 하는 원칙. 해시 함수를 사용함으로써 보장.
    * 다. 인증(Authentication): 수신된 메시지가 허용된 송신자로부터 전달된 것인가를 확인하고 송수신자가 상대방의 신원을 확인하는 과정
        * A. 사용자 인증: 정보의 생성, 전송, 처리 등의 행위에 관하여 사용자가 바로 그 사용자임을 보증.
        * B. 메시지를 생성한 사용자가 누구인지를 확인할 수 있는 것. 출처 인증
    * 라. 부인방지(Non-Repudiation): 메시지의 송수신 후, 송신 또는 수신 사실을 부인 방지. 전자서명을 사용함으로써 보장
* 케르히호프 원리(Kerckhoff’s principle): 키를 제외한 시스템의 모든 내용이 알려지더라도 암호체계는 안전해야 함. 암호의 안전성은 알고리즘이 아니라 키의 비밀성에만 의존해야 함.
* 암/복호화 키에 따라 대칭키/비대칭키 암호로 나눔.
* 정보의 엔트로피.
![엔트로피](https://user-images.githubusercontent.com/63287638/124376419-e3a62180-dce1-11eb-86d9-2adf82c6ea88.png)
n비트 이진 스트링들로 이루어진 계의 엔트로피: Pi 대신 1/2^n 이 들어가고 H의 값은 n이 됨. 이는 가능한 정보들을 인코딩하기 위한 평균 비트수를 의미.  
_cf) 물리학에서 엔트로피는 무질서함을 의미. 실제 세계에선 엔트로피가 증가하는 방향으로 움직임._  
_cf) 샤논의 정리: 완전 비밀(Perfect Secrecy이란 || K || >= || M || 이란 전제에서, 암호문이 C일 때 해당되는 평문이 M일 확률은 그저 1 / || M ||임. 즉, P( M | C ) = P( M )이 성립. (여기서 || 는 안에 내용을 인코딩한 비트수를 의미). 키는 메시지와 다른 안전한 채널로 전송해야 하므로, 결국 완전 비밀을 유지하면서 암호화하기란 비효율적임을 의미._  





## 4. 보안 개발 - 창과 방패
by 최바울
1) 아
가.
가)

